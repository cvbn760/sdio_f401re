#include "fw_updater.h"
#include "gpio.h"
#include "i2c_manager.h"

#define SNP_ADDR 0x36
#define LOCKBYTE_ONE_ADDR 0x42FF
#define LOCKBYTE_THREE_ADDR 0x407F
#define UNLOCK_AREA 0xFF

static uint8_t sensor_number = 2;


static BOOLEAN prep_firmware(void);
static BOOLEAN reset_to_factory(void);
//static BOOLEAN set_lockbyte(UINT16 lock_addr, char value);


static BOOLEAN reset_to_factory(void){
     // 1) write to 0x36 ack data: 0xA2 0x01 0x76 0x32
     uint8_t reset_cmd_1[4] = {0xA2, 0x01, 0x76, 0x32};
     if(!i2c_send_data_to_device(SNP_ADDR, &reset_cmd_1, 4)) return FALSE;

     // 2) write to 0x36 ack data: 0xA2, 0x02, 0x46, 0x51
     uint8_t reset_cmd_2[4] = {0xA2, 0x02, 0x46, 0x51};
     if(!i2c_send_data_to_device(SNP_ADDR, reset_cmd_2, 4)) return FALSE;

     return TRUE;
}

extern BOOLEAN update_firmware(void){
	// Подготовка к прошивке
    if(!prep_firmware()) {
    	printf("Can't switch SNP73X to programming mode\n");
    	return FALSE;
    }
    printf("Switch SNP73X to factory state was success\n");

    // Возврат заводской прошивки
    if(!reset_to_factory()) {
    	printf("Can't rollback SNP76X to factory state\n");
    	return FALSE;
    }
    printf("Reset to factory was success\n");


//    // 3) write to 0x36 ack data: 0x00 0x00 0x80 0x0E 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x56 0x31 0x2E 0x32 0xFF 0xFF 0xFF 0xFF 0x75 0xA2 0x04 0x53 0x89 0xFC 0x75 0x81 0x26 0x12 0x02 0x22 0x53 0xC0 0x9F 0x43 0xC0 0x20 0x75 0xD8 0x00 0x75 0xE8 0x00 0x75 0xF8 0x00 0x90 0x60 0x73 0xE0 0x54 0x1F 0xF5 0xA3 0x43 0xC0 0x40 0x75 0x8A 0x00 0x43 0x89 0x02 0x43 0x8D 0x80 0x75 0x6A 0x38
//    char data_3[100] = {0x00, 0x00, 0x80, 0x0E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x56, 0x31, 0x2E, 0x32, 0xFF, 0xFF, 0xFF, 0xFF, 0x75, 0xA2, 0x04, 0x53, 0x89, 0xFC, 0x75, 0x81, 0x26, 0x12, 0x02, 0x22, 0x53, 0xC0, 0x9F, 0x43, 0xC0, 0x20, 0x75, 0xD8, 0x00, 0x75, 0xE8, 0x00, 0x75, 0xF8, 0x00, 0x90, 0x60, 0x73, 0xE0, 0x54, 0x1F, 0xF5, 0xA3, 0x43, 0xC0, 0x40, 0x75, 0x8A, 0x00, 0x43, 0x89, 0x02, 0x43, 0x8D, 0x80, 0x75, 0x6A, 0x38 };
//    //                    1     2     3      4    5     6     7     8     9     10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25    26     27   28    29    30    31    32    33    34    35    36    37    38    39    40    41    42    43    44    45    46    47    48    49    50    51    52    53    54    55    56    57    58    59    60    61    62    63    64    65    66    67    68
//    //                  0x00  0x00  0x80  0x0E  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0x56  0x31  0x2E  0x32  0xFF  0xFF  0xFF  0xFF  0x75  0xA2  0x04  0x53  0x89  0xFC  0x75  0x81  0x26  0x12  0x02  0x22  0x53  0xC0  0x9F  0x43  0xC0  0x20  0x75  0xD8  0x00  0x75  0xE8  0x00  0x75  0xF8  0x00  0x90  0x60  0x73  0xE0  0x54  0x1F  0xF5  0xA3  0x43  0xC0  0x40  0x75  0x8A  0x00  0x43  0x89  0x02  0x43  0x8D  0x80  0x75  0x6A  0x38
//    i2c_send_data_to_device(0x36, data_3, 68);
//
//
    // 4) write to 0x36 ack data: 0x40 0x00 0x00 0x00 0x00 0x08 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x05 0x69
    char data_4[100] = {0x40, 0x00, sensor_number, 0x00, 0x00, 0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x69};
    i2c_send_data_to_device(0x36, data_4, 68);



    //write to 0x36 ack data: 0x40 0x00
    //read to 0x36 ack data: 0x00 0x00 0x00 0x08 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x03 0x97
    //                        1     2    3   4    5    6    7    8    9    10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66
    char buff[66];
    memset(&buff[0], 0x00, 66);
    i2c_read_data_from_device(0x36, 0x4000, buff, 66);

    printf("FW was finish\n");
    return TRUE;
}

static BOOLEAN prep_firmware(void){
	// Перевод SDA/SCL пинов в режим GPIO
	switch_mode_sda_scl(GPIO_M);

	set_sda(GPIO_PIN_RESET);   // SDA off
	set_scl(GPIO_PIN_RESET);   // SCL off
	set_power(GPIO_PIN_RESET); // VDD off
	osDelay(1000);
 	set_power(GPIO_PIN_SET);   // VDD on

	// GPIO0(SCL) GPIO1(SDA) должны удерживаться в состояниий  GPIO1 = 1, GPIO0 = 0 не менее 256 мсек
	set_sda(GPIO_PIN_RESET);    // SDA on
	set_scl(GPIO_PIN_SET);  // SCL off
	osDelay(2000);

	// Перевод SDA/SCL пинов в режим I2C
	switch_mode_sda_scl(I2C_M);
	osDelay(1000);

	// Убедиться, что на шине появилось устройство с адресом 0x36
    scan_bus_and_print();
	return has_device(SNP_ADDR);
}

//static BOOLEAN set_lockbyte(UINT16 lock_addr, char value){
//	char lock[4] = {0x00, 0x00, 0x00, 0x00};
//	return TRUE;
//}


